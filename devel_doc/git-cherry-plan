#!/bin/bash

PROGRAM=cherry-plan
DIR=$HOME/.$PROGRAM
BRANCH=$(git rev-parse --abbrev-ref HEAD)
FILE=$DIR/$BRANCH
EDITOR=$(git config --default vim --get core.editor)

UPSTREAM=master
BASE=$(git merge-base HEAD $UPSTREAM)
DELIM="--- >8 ---"
ABBREV=10

README="\
# Cherry-pick $BRANCH..$UPSTREAM onto $BRANCH
# vim:syntax=gitrebase
#
# Commands:
# pick <commit> = use commit
# drop <commit> = remove commit, not suitable
# skip <commit> = ignore commit, already applied
#      <commit> = ignore commit, needs review
#
# These lines MUST NOT be re-ordered or removed.
#
# Priorities (descending order):
# 1) regression, crash and security fixes
# 2) user visible breakage with no workarounds
# 3) user visible breakage with major impact
# 4) other major impact stuff (if budget allows)
#
# Budget: 30 commits
# Lines containing #test or #docs do not count against the budget.
"

usage() {
    echo "\
Usage: git $PROGRAM COMMAND [ARGS]

Manage a persistent git rebase-like todo list to cherry-pick upstream commits
onto a stable branch when making releases.

The list (a \"plan\") contains all commits on $UPSTREAM since the branching
point, with a help message at the top, and is stored in a per-branch file.

Commands:
    init [BRANCH]       make new plan for current branch
                        (or copy from existing BRANCH)
    edit                open plan in editor
    rm                  remove plan
    ls                  list all plans
    pull                append new commits from $UPSTREAM
    update              mark applied commits
    apply               apply plan
    start               mark commits above $DELIM with drop
    format              print plan for e-mail review
                        (only commits below $DELIM)
    status              show plan status"
    exit 1
}

ensure_exists() {
    if [ ! -f $FILE ]; then
        echo "No plan exists for this branch yet" >&2
        exit 1
    fi
}

ensure_not_exists() {
    if [ -f $FILE ]; then
        echo "This branch already has a plan" >&2
        exit 1
    fi
}

applied() {
    local log=$(git log --format="%b" $BASE..)
    echo "$log" | sed -n 's/^(cherry picked from commit \(.*\))/\1/p'
    echo "$log" | sed -n 's/^Backported from commit \(.*\)/\1/p'
}

mark() {
    sed -i "s/^skip /     /" $1
    applied | while read line; do
        sed -i "s/^.\{5\}\($(echo $line | cut -c -$ABBREV)\)/skip \1/" $1
    done
}

log() {
    git log --reverse --abbrev=$ABBREV --format="     %h %s" $1..$UPSTREAM
}

budget() {
    sed -n 's/^# Budget: \(.*\) commits$/\1/p' $1
}

gethash() {
    sed 's/^.\{5\}//' | cut -d' ' -f1
}

CMD=$1
shift
if [ "$CMD" == "init" ]; then
    ensure_not_exists
    mkdir -p $DIR
    if [ -z "$1" ]; then
        echo "$README" > $FILE
        log $BASE >> $FILE
        mark $FILE
    else
        cp $DIR/$1 $FILE
    fi
elif [ "$CMD" == "pull" ]; then
    ensure_exists
    log $(tail -1 $FILE | gethash) | tee -a $FILE
elif [ "$CMD" == "update" ]; then
    ensure_exists
    mark $FILE
elif [ "$CMD" == "start" ]; then
    ensure_exists
    sed -i "0,/^# $DELIM$/ s/^     /drop /" $FILE
elif [ "$CMD" == "edit" ]; then
    ensure_exists
    $EDITOR $FILE
elif [ "$CMD" == "rm" ]; then
    ensure_exists
    rm -i $FILE
elif [ "$CMD" == "ls" ]; then
    ls -1 $DIR
elif [ "$CMD" == "format" ]; then
    ensure_exists
    sed "/^[^#].*$/,$ d" $FILE
    sed "0,/^# $DELIM$/ d" $FILE
elif [ "$CMD" == "status" ]; then
    ensure_exists
    last=$(tail -1 $FILE | gethash)
    count=$(git rev-list --count $last..$UPSTREAM)
    if [ "$count" == "0" ]; then
        echo "Your plan is up to date with '$UPSTREAM'."
    else
        echo "Your plan is behind '$UPSTREAM' by $count commits."
    fi
    picked=$(grep '^pick ' $FILE | grep -v '#\(test\|docs\)' | wc -l)
    unmarked=$(grep '^     ' $FILE | wc -l)
    echo "$picked/$(budget $FILE) picked, $unmarked unmarked"
elif [ "$CMD" == "apply" ]; then
    ensure_exists
    grep '^pick ' $FILE | while read line; do
        commit=$(echo "$line" | gethash)
        echo "Applying commit $commit"
        git cherry-pick -x $commit >/dev/null || exit 1
    done
    echo "Plan applied successfully!"
else
    usage
fi
