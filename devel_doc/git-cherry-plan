#!/bin/bash

PROGRAM=cherry-plan
DIR=$HOME/.$PROGRAM
BRANCH=$(git rev-parse --abbrev-ref HEAD)
FILE=$DIR/$BRANCH
EDITOR=$(git config --default vim --get core.editor)
UPSTREAM=master
BASE=$(git merge-base HEAD $UPSTREAM)
ABBREV=10
README="\
# Cherry-pick plan from $UPSTREAM onto $BRANCH
# vim:syntax=gitrebase
#
# Commands:
# pick <commit> = use commit
# drop <commit> = ignore commit, not appropriate
#      <commit> = ignore commit, not reviewed
# skip <commit> = ignore commit, already applied
#
# These lines MUST NOT be re-ordered or removed; they are executed from top to
# bottom.
"

usage() {
    echo "\
Usage: git $PROGRAM <command> [<arg>...]

Manage persistent rebase-like todo lists (\"plans\"), one per branch.
Think of a plan as a \"branch index\" for staging your picks.

Useful for handling complex rebases that may also need peer review, such as
cherry-picking commits onto a stable branch.

Commands:
    init [<upstream>]   make plan for current branch
                        ($UPSTREAM if <upstream> is omitted)
    edit                open plan in editor
    cp <branch>         copy plan from <branch>
    rm                  remove plan
    ls                  list all plans
    pull [<upstream>]   append new upstream commits to plan
                        ($UPSTREAM if <upstream> is omitted)
    update              mark applied commits in plan
    apply               apply plan
    dump                print plan to stdout
    status              show plan status"
    exit 1
}

ensure_exists() {
    if [ ! -f $FILE ]; then
        echo "No plan exists for this branch yet" >&2
        exit 1
    fi
}

ensure_not_exists() {
    if [ -f $FILE ]; then
        echo "This branch already has a plan" >&2
        exit 1
    fi
}

get_hash() {
    sed 's/^.\{5\}//' | cut -d' ' -f1
}

get_applied() {
    local log=$(git log --format="%b" $1..)
    echo "$log" | sed -n 's/^(cherry picked from commit \(.*\))/\1/p'
    echo "$log" | sed -n 's/^Backported from commit \(.*\)/\1/p'
}

get_base() {
    git merge-base HEAD $1
}

get_last() {
    sed '/^#/d; /^$/d' $FILE | tail -1 | get_hash
}

mark() {
    sed -i "s/^skip /     /" $FILE
    get_applied $1 | while read line; do
        sed -i "s/^.\{5\}\($(echo $line | cut -c -$ABBREV)\)/skip \1/" $FILE
    done
}

log() {
    git log --reverse --abbrev=$ABBREV --format="$2 %h %s" $1..$UPSTREAM
}

CMD=$1
shift
if [ "$CMD" == "init" ]; then
    ensure_not_exists
    base=$(get_base ${1:-$UPSTREAM})
    mkdir -p $DIR
    echo "$README" > $FILE
    log $base "drop" >> $FILE
    mark $base
elif [ "$CMD" == "pull" ]; then
    ensure_exists
    log $(get_last) "    " | tee -a $FILE
elif [ "$CMD" == "update" ]; then
    ensure_exists
    mark $BASE
elif [ "$CMD" == "edit" ]; then
    ensure_exists
    $EDITOR $FILE
elif [ "$CMD" == "cp" ]; then
    ensure_not_exists
    cp $DIR/$1 $FILE
elif [ "$CMD" == "rm" ]; then
    ensure_exists
    rm -i $FILE
elif [ "$CMD" == "ls" ]; then
    ls -1 $DIR
elif [ "$CMD" == "status" ]; then
    ensure_exists
    count=$(git rev-list --count $(get_last)..$UPSTREAM)
    picked=$(grep '^pick ' $FILE | wc -l)
    unmarked=$(grep '^     ' $FILE | wc -l)
    if [ "$count" == "0" ]; then
        echo "Your plan is up to date with '$UPSTREAM'."
    else
        echo "Your plan is behind '$UPSTREAM' by $count commits."
    fi
    echo "$picked picked, $unmarked unmarked"
elif [ "$CMD" == "dump" ]; then
    ensure_exists
    cat $FILE
elif [ "$CMD" == "apply" ]; then
    ensure_exists

    grep '^pick ' $FILE | while read line; do
        commit=$(echo "$line" | get_hash)
        echo "Applying commit $commit"
        git cherry-pick -x $commit >/dev/null || exit 1
    done

    echo "Plan applied successfully!"
else
    usage
fi
